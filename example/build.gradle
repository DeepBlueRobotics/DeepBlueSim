plugins {
    id "java"
    id "edu.wpi.first.GradleRIO" version "2021.1.2"
    id "org.team199.deepbluesim" version "0.0.12"
}

sourceCompatibility = JavaVersion.VERSION_11
targetCompatibility = JavaVersion.VERSION_11

def ROBOT_MAIN_CLASS = "frc.robot.Main"

// Define my targets (RoboRIO) and artifacts (deployable files)
// This is added by GradleRIO's backing project EmbeddedTools.
deploy {
    targets {
        roboRIO("roborio") {
            // Team number is loaded either from the .wpilib/wpilib_preferences.json
            // or from command line. If not found an exception will be thrown.
            // You can use getTeamOrDefault(team) instead of getTeamNumber if you
            // want to store a team number in this file.
            team = frc.getTeamNumber()
        }
    }
    artifacts {
        frcJavaArtifact('frcJava') {
            targets << "roborio"
            // Debug can be overridden by command line, for use with VSCode
            debug = frc.getDebugOrDefault(false)
        }
        // Built in artifact to deploy arbitrary files to the roboRIO.
        fileTreeArtifact('frcStaticFileDeploy') {
            // The directory below is the local directory to deploy
            files = fileTree(dir: 'src/main/deploy')
            // Deploy to RoboRIO target, into /home/lvuser/deploy
            targets << "roborio"
            directory = '/home/lvuser/deploy'
        }
    }
}

// Set this to true to enable desktop support.
def includeDesktopSupport = true

// Defining my dependencies. In this case, WPILib (+ friends), and vendor libraries.
// Also defines JUnit 4.
dependencies {
    implementation wpi.deps.wpilib()
    nativeZip wpi.deps.wpilibJni(wpi.platforms.roborio)
    nativeDesktopZip wpi.deps.wpilibJni(wpi.platforms.desktop)


    implementation wpi.deps.vendor.java()
    nativeZip wpi.deps.vendor.jni(wpi.platforms.roborio)
    nativeDesktopZip wpi.deps.vendor.jni(wpi.platforms.desktop)

    testImplementation 'junit:junit:4.12'

    // Enable simulation gui support (except during Continuous Integration).
    // Must check the box in vscode to enable support upon debugging
    if (System.getenv()['CI'] == null) {
        simulation wpi.deps.sim.gui(wpi.platforms.desktop, false)
        simulation wpi.deps.sim.driverstation(wpi.platforms.desktop, false)
    }

    // Websocket extensions require additional configuration.
    simulation wpi.deps.sim.ws_server(wpi.platforms.desktop, false)
    // simulation wpi.deps.sim.ws_client(wpi.platforms.desktop, false)
}

// Setting up my Jar File. In this case, adding all libraries into the main jar ('fat jar')
// in order to make them all available at runtime. Also adding the manifest so WPILib
// knows where to look for our Robot Class.
jar {
    from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
    manifest edu.wpi.first.gradlerio.GradleRIOPlugin.javaManifest(ROBOT_MAIN_CLASS)
}

// Support a systemTest task that runs a system level functional test in the simulator

sourceSets {
    systemTest {
        compileClasspath += sourceSets.main.output
        runtimeClasspath += sourceSets.main.output
    }
}

configurations {
    systemTestImplementation.extendsFrom testImplementation
    systemTestRuntimeOnly.extendsFrom runtimeOnly    
}

task('systemTestJar', type: Jar) {
    archiveBaseName = 'systemTest'
    from sourceSets.main.output
    from sourceSets.systemTest.output
    from { configurations.systemTestRuntimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
    manifest edu.wpi.first.gradlerio.GradleRIOPlugin.javaManifest("frc.robot.SystemTestRobot")
}

task('systemTest', type: SynchronousJavaSimulationTask) {
    dependsOn 'systemTestJar'
    dependsOn 'extractTestJNI'
}

assemble.dependsOn installDeepBlueSim

check.dependsOn 'systemTest'

class SynchronousJavaSimulationTask extends edu.wpi.first.gradlerio.test.JavaSimulationTask {
    @Override
    Process launch(List<String> cmd) {
        // Let the base class handle these situations
        if (scriptOnly || project.hasProperty('headless')) {
            return super.launch(cmd)
        }
        // Remove the extraneous double quotes added by the caller
        cmd = cmd*.replace('"','')
        def builder = new ProcessBuilder(cmd)
        // Incorporate the task's env and the simulation extension's env (e.g. HALSIM_EXTENSIONS)
        def env = builder.environment()
        env.putAll environment
        env.putAll project.extensions.getByType(edu.wpi.first.gradlerio.wpi.simulation.SimulationExtension).environment
        // Set the working dir if specified
        if (workingDir != null) {
            workingDir.mkdirs()
            builder.directory(workingDir)
        }
        // Redirect stderr to stdout
        builder.redirectErrorStream(true)
        // Start the process
        Process p = builder.start()
        println "Waiting for simulation to finish..."
        // Copy the output asynchronously so that the current thread can be interrupted
        // (e.g. if the task times out)
        try {
            p.inputStream.withStream { stream ->
                def executor = java.util.concurrent.Executors.newFixedThreadPool(1)
                def copyStreamCallable = new java.util.concurrent.Callable<Integer>() {
                    def buf = new byte[8192]
                    @Override
                    Integer call() {
                        int length = stream.read(buf)
                        if (length > 0) 
                            System.out.write(buf, 0, length)
                        return length
                    }
                }
                while (executor.submit(copyStreamCallable).get() > 0) {
                }
            }
        } catch (InterruptedException) {
            p.destroy()
        }
        p.waitFor()
        if (p.exitValue() != 0)
            throw new RuntimeException("Simulation failed with exit code ${p.exitValue()}.")
        return p
    }
}

